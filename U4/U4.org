* Lösning
** Lodrätt
*** Lodrätt 1
(10 1110 0011)_2 -> BCD-kod

Gör om till decimalt
1011100011 = 739 dec ("fuskade" och använde en räknare här)
Vi ska då representera 7, 3 och 9 binärt

7 = (8*0) + (4*1) + (2*1) + (1*1) = 0111
3 = (8*0) + (4*0) + (2*1) + (1*1) = 0011
9 = (8*1) + (4*0) + (2*0) + (1*1) = 1001

*Svar*: 0111 0011 1001

*** Lodrätt 2
(11 1100 0111)_2 -> oktalt

Börja med att gruppera om siffror till 3 och 3
001 111 000 111

Sätt "421" under varje grupp och addera talsumman

| 001 | 111 | 000 | 111 |
| 421 | 421 | 421 | 421 |
|-----+-----+-----+-----|
|   1 |   7 |   0 | 7   |

*Svar*: (11 1100 0111)_2 => (1707)_8
*** Lodrätt 3
(1111 0000 0000 1110)_2 -> Hexadecimalt

Ungefär samma tillvägagångssätt som ovan, men gruppera om fyra

| 1111 | 0000 | 0000 | 1110 |
| 8421 | 8421 | 8421 | 8421 |
|------+------+------+------|
|    F |    0 |    0 | E    |
*Svar* (1111 0000 0000 1110)_2 => (F00E)_{16}

*** Lodrätt 4
ASCII(55_{10}), dvs ASCII-tecknet för talet 55_{10}
Det går att utläsa från valfri ASCII-tabell att 55_{10} => 7
*** Lodrätt 5
119_{10} -> Okt

119 / 8 = 14 + *7*
14  / 8 = 1  + *6*
1   / 8 = 0  + *1*

*Svar: 119_{10} => 167_{8}

*** Lodrätt 6
732_{8} -> binärt
Ta en siffra i taget, vänster till höger, och representera den binärt med tre
siffror. "Sätt ihop" resultaten.

7 => 111
3 => 011
2 => 010

*Svar: 111 011 010

*** Lodrätt 7
(267B)_{16} -> decimalt

Ställ upp en tabell på vad varje sifferposition är värd

| 16^3 | 16^2 | 16^1 |   16^0 |
| 4096 |  256 |   16 |      1 |
|------+------+------+--------|
|    2 |    6 |    7 | 11 (b) |

(2*4096) + (6*256) + (7*16) + (11*1) = 9851

*Svar*: (267B)_{16} => (9851)_10

*** Lodrätt 8
1101011_2 -> Graykod

Vi kan ta två siffror i taget, höger från vänster, och XOR:a dem

#+BEGIN_SRC
1101011
     ^^
1 XOR 1 = 0

1101011
    ^^
0 XOR 1 = 1

1101011
   ^^
1 XOR 0 = 1

1101011
  ^^
0 XOR 1 = 1

1101011
 ^^
1 XOR 0 = 1

1101011
^^
1 XOR 1 = 0
#+END_SRC

Sedan läser man nedifrån och upp => 011110, men lägger siffran längst till
vänster från binära talet (1) först i gray-koden => 1 + 011110 = 1011110

*Svar*: 1011110

*** Lodrätt 9
0010111_{2} i 2-komp

#+BEGIN_SRC
0010111
1101000

Lägg på 1
1101001
#+END_SRC

*Svar*: 1101001
** Vågrätt
*** Vågrätt 1
0010 0001 0001_{BCD} -> Decimalt

Ta varje grupp för sig, $0010$ kan jag snabbt avgöra är 2, $0001$ = 1, $0001$ =
1. Så svaret är då (211)_{10}

*** Vågrätt 2
(261)_{8} -> decimalt

| 8^2 | 8^1 | 8^0 |
|  64 |   8 |   1 |
|-----+-----+-----|
|   2 |   6 |   1 |

(2*64) + (6*8) + (1*1) = 177

*Svar*: 177 dec, vilket vi redan har fått från Lodrätt 1, 2 och 4. Bra!

*** Vågrätt 3
13E_{16} -> binärt

Jag tänker lite som med BCD-koden, representera 1, 3 och E (14) binärt,
grupperat om 4 siffror.

1 => 0001
3 => 0011

Att räkna ut E (14) är ju däremot något jobbigare. Men vi börjar med att
subtrahera 8 och fyller i en 1 på första position.

| 8 | 4 | 2 | 1 |
| 1 |   |   |   |

Då ska vi representera (14-8) = 6 binärt. Så vi bockar i 4 och 2, då det blir 6
och vi har inget överskott.

| 8 | 4 | 2 | 1 |
| 1 | 1 | 1 | 0 |

E => 1110

*Svar*: 0001 0011 1110 (alt 100 111 110)

*** Vågrätt 4
Talet (decimalt) som get "k" (inte "K") som ASCII-tabell

Det är bara att kika på valfri ASCII-tabell.

*Svar*: 107

*** Vågrätt 5
(8033)_{10} -> hexadecimalt

8033 / 16 = 502 + 1
502 / 16 = 31 + 6
31 / 16 = 1 + F
1 / 16 = 0 + 1

*Svar*: 1F61
Vilket jag redan hade fått ifyllt, bra!

*** Vågrätt 6
11CD_{16} -> okt

Konvertera =1 1 C D= till binärt

#+BEGIN_SRC
1 => 0001
1 => 0001
C => 1100
D => 1101
  => 0001 0001 1100 1101
#+END_SRC

Gruppera om i 3 och 3 och konvertera
=1 000 111 001 101=
=1   0   7   1   5=

*Svar*: 10715
Vilket jag redan hade fått ifyllt, bra!

*** Vågrätt 7
602_{10} -> binärt

#+BEGIN_SRC
602 / 2 = 301 + 0
301 / 2 = 150 + 1
150 / 2 = 75  + 0
75  / 2 = 37  + 1
37  / 2 = 18  + 1
18  / 2 = 9   + 0
9   / 2 = 4   + 1
4   / 2 = 2   + 0
2   / 2 = 1   + 0
1   / 2 = 0   + 1
#+END_SRC

*Svar*: 1001 0110 10

*** Vågrätt 8
7241_8 -> hex

Ledningen säger att man inte ska gå via decimalt, vilket jag håller med om.
Däremot känns det enkelt att gå via binärt, då 7 => 111 och F => 1111. Så jag
börjar med att konvertera 7, 2, 4, 1 till binärt, därifrån till hex.

#+BEGIN_SRC
Okt => Bin
7   => 111
2   => 010
4   => 100
1   => 001
#+END_SRC

Så det är 111010100001 binärt. Gruppera om det i par om fyra, konvertera till
hex.

#+BEGIN_SRC
Bin  => Hex
1110 => E
1010 => A
0001 =) 1
#+END_SRC

Svar: (0)EA1.

*** Vågrätt 9
0110_2 - 0011_2, använd tvåkomplement

Gör om 0011 till tvåkomplement: invertera 0 => 1, 1 => 0 och lägg på en etta.
Addera ihop talen istället för att subtrahera.

#+BEGIN_SRC
0011 ==[tvåkomplement]==> 1101

  1
  0110
+ 1101
------
 10011
 ^
 Resultatet är positivt
#+END_SRC

*Svar*: 0011

Jag får det inte att passa in med lodrätt 9. Jag har dubbelkolllat svaren på
båda frågor och det ska stämmas. Jag dubbelkollade lodrätt 9 mot en räknare och
får samma svar.

Gör jag om 0110_2 till tvåkomplement så får jag också ut 0011_2 (fast negativ).

*** Vågrätt 10
00010_2 - 01001_2, använd tvåkomplement

#+BEGIN_SRC
01001 ==[tvåkomplement]==> 10111

   11
  00010
+ 10111
-------
 011001
 ^
 Resultatet är negativt
#+END_SRC

*Svar*: 11001_2
